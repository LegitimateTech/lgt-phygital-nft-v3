// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.2;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "./Locked721AccessControl.sol";

abstract contract Locked721 is ERC721, Locked721AccessControl {
    using Strings for uint256;

    // stores the locked state for each NFT
    mapping(uint256 => bool) tokenLock;

    constructor() {
      // contract deployer is the admin by default
      _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
      // contract deployer can be granted some initial roles to start with
      _setupRole(API_DELEGATE_ROLE, msg.sender);

      // set default admin as the manager of claim and unlock delegate roles
      _setRoleAdmin(API_DELEGATE_ROLE, DEFAULT_ADMIN_ROLE);
    }

    // TOKENLOCK FUNCTIONS
    function _setTokenLock(uint256 tokenId, bool locked) internal {
      tokenLock[tokenId] = locked;
    }

    function setTokenLock(uint256 tokenId, bool locked) public onlyApiDelegate {
      _setTokenLock(tokenId, locked);
    }

    // READ TOKENLOCK STATE FUNCTIONS
    function _getTokenLock(uint256 tokenId) internal virtual view returns (bool) {
      return tokenLock[tokenId];
    }

    function getTokenLock(uint256 tokenId) public view returns (bool) {
      return _getTokenLock(tokenId);
    }

    // if a token is locked, then this function returns true, 
    // unless the token is being minted,
    // or the message sender has an API DELEGATE role and is claiming the token,
    // or the token is being burned 
    function _shouldPreventTokenTransfer (address from, address to, uint256 tokenId) internal virtual view returns (bool) {
        return 
        from != address(0) && // is not minting token
        !(from == msg.sender && hasRole(API_DELEGATE_ROLE, msg.sender)) && // is not claiming token
        to != address(0) && // is not burning token
        _getTokenLock(tokenId); // token is locked
    }

    // @todo: is not gas optimized since _afterTokenTransfer sets lock = true and then this sets lock = false
    // This is used for end users to claim NFTs minted to our delegate wallet and makes the claim activation gasless for end users
    // the delegate wallet performing the claim functionality needs to own the NFT
    // we check the ownership information on our API service used by Tap
    function claim(address to, uint256 tokenId) public onlyApiDelegate {
      require(_isApprovedOrOwner(msg.sender, tokenId));

      _transfer(msg.sender, to, tokenId);
      _setTokenLock(tokenId, false);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
    internal
    virtual
    override(ERC721)
    {
      require(!_shouldPreventTokenTransfer(from, to, tokenId), "Please unlock your NFT by tapping the LGT Tag before transferring.");
      super._beforeTokenTransfer(from, to, tokenId, batchSize);
    }

    // This locking mechanism disencentivizes people from separately selling the NFT without the physical item
    // in order to unlock. The owner of the NFT will need to unlock with the params generated by the LGT tag
    // and verified by LGT's servers. Since the unlock is done by LGT, the transaction is gasless for end users
    // and the gas is paid by Legitimate as part of the ongoing service contract.
    // Exclusive content and other experiences can also be gated behind this lock mechanism as well.
    function _afterTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) override(ERC721) internal virtual {
      super._afterTokenTransfer(from, to, tokenId, batchSize);
      _setTokenLock(tokenId, true);
    }

    // The following functions are overrides required by Solidity for ERC-165
    function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(ERC721, AccessControl)
    returns (bool)
    {
      return ERC721.supportsInterface(interfaceId) || AccessControl.supportsInterface(interfaceId);
    }
}